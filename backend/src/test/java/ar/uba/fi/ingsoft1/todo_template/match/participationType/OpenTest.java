package ar.uba.fi.ingsoft1.todo_template.match.participationType;

import ar.uba.fi.ingsoft1.todo_template.user.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class OpenTest {

    private User user1, user2, user3;

    @BeforeEach
    void setUp() {
        user1 = mock(User.class);
        user2 = mock(User.class);
        user3 = mock(User.class);
    }

    @Test
    void testConstructorAndGetters() {
        HashSet<User> players = new HashSet<>(Set.of(user1, user2));
        Open open = new Open(2, 4, players);

        assertEquals(2, open.getMinPlayersCount());
        assertEquals(4, open.getMaxPlayersCount());
        assertEquals(2, open.getPlayerCount());
        assertTrue(open.getPlayers().contains(user1));
    }

    @Test
    void testAddPlayerSuccessfully() {
        Open open = new Open(1, 3, new HashSet<>());
        assertTrue(open.addPlayer(user1));
        assertTrue(open.getPlayers().contains(user1));
        assertEquals(1, open.getPlayerCount());
    }

    @Test
    void testAddPlayerFailsIfAlreadyPresent() {
        HashSet<User> initialPlayers = new HashSet<>(Set.of(user1));
        Open open = new Open(1, 3, initialPlayers);

        assertFalse(open.addPlayer(user1));
    }

    @Test
    void testAddPlayerFailsIfFull() {
        HashSet<User> fullPlayers = new HashSet<>(Set.of(user1, user2, user3));
        Open open = new Open(1, 3, fullPlayers);
        User newUser = mock(User.class);

        assertFalse(open.addPlayer(newUser));
    }

    @Test
    void testLeaveMatchSuccessfully() {
        HashSet<User> players = new HashSet<>(Set.of(user1, user2));
        Open open = new Open(1, 3, players);

        assertTrue(open.leaveMatch(user1));
        assertFalse(open.getPlayers().contains(user1));
    }

    @Test
    void testLeaveMatchFailsIfNotPresent() {
        Open open = new Open(1, 3, new HashSet<>());
        assertFalse(open.leaveMatch(user1));
    }

    @Test
    void testCheckStartThrowsIfTooFewPlayers() {
        HashSet<User> players = new HashSet<>(Set.of(user1)); // only 1 player
        Open open = new Open(2, 4, players);

        Exception ex = assertThrows(IllegalStateException.class, open::checkStart);
        assertEquals("Not enough players!", ex.getMessage());
    }

    @Test
    void testCheckStartThrowsIfOddNumberOfPlayers() {
        HashSet<User> players = new HashSet<>(Set.of(user1, user2, user3)); // 3 players
        Open open = new Open(2, 4, players);

        Exception ex = assertThrows(IllegalStateException.class, open::checkStart);
        assertEquals("The number of players must be even!", ex.getMessage());
    }

    @Test
    void testCheckStartPassesWithEvenPlayers() {
        HashSet<User> players = new HashSet<>(Set.of(user1, user2));
        Open open = new Open(2, 4, players);

        assertDoesNotThrow(open::checkStart);
    }

    @Test
    void testToStringFormat() {
        Open open = new Open(2, 4, new HashSet<>());
        String str = open.toString();

        assertTrue(str.contains("type: 'Open'"));
        assertTrue(str.contains("minPlayersCount: 2"));
        assertTrue(str.contains("maxPlayersCount: 4"));
    }
}
